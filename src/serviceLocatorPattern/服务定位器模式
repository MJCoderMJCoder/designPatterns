服务定位器模式（Service Locator Pattern）：
	服务定位器模式用在我们想使用JNDI[命名和目录服务(Java Naming And Directory Interface)]查询定位各种服务的时候。
	考虑到为某个服务查找JNDI的代价很高，服务定位器模式充分利用了缓存技术。
	在首次请求某个服务时，服务定位器在JNDI中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。
	以下是这种设计模式的实体：
		服务（Service） - 实际处理请求的服务。对这种服务的引用可以在JNDI服务器中查找到。
		Context / 初始的 Context - JNDI Context带有对要查找的服务的引用。
		服务定位器（Service Locator） - 服务定位器是通过JNDI查找和缓存服务来获取服务的单点接触。
		缓存（Cache） - 缓存存储服务的引用，以便复用它们。
		客户端（Client） - Client 是通过ServiceLocator调用服务的对象。

实例：
	创建 ServiceLocator、InitialContext、Cache、Service作为表示（服务定位器模式的）实体的各种对象。Service1 和 Service2 表示实体服务。
	ServiceLocatorPatternDemo，演示类在这里是作为一个客户端，将使用 ServiceLocator来演示服务定位器设计模式。
	
	
static关键字在Java中：
	有时希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。
在成员的声明前面加上关键字static（静态的）就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声
明为static。static 成员的最常见的例子是main（）。因为在程序开始执行时必须调用main() ，所以它被声明为static。声明为static的变量称为静态变量或类变量。可以直接通过类名引
用静态变量，也可以通过实例名来引用静态变量，但最好采用前者，因为后者容易混淆静态变量和一般变量。静态变量是跟类相关联的，类的所有实例共同拥有一个静态变量。声明为static的方法称为
静态方法或类方法。静态方法可以直接调用静态方法，访问静态变量，但是不能直接访问实例变量和实例方法。静态方法中不能使用this关键字，因为静态方法不属于任何一个实例。
	如果需要通过计算来初始化static变量，可以声明一个static块，Static 块仅在该类被加载时执行一次。
	注意：在一个static方法中引用任何实例变量都是非法的。
	使用 static修饰符声明属于类型本身而不是属于特定对象的静态成员。static修饰符可用于字段、方法、属性、运算符、事件和构造函数，但不能用于索引器、析构函数或类以外的类型。